/* *************************************************************** */
/* File: lag_fsm.c */
/* Class/Module: LagMngr */
/*  */
/* Purpose: */
/* Description: Lag  state machine implementation */
/* graphic representation of the FSM can be found in  LagFSM.gml . open file in Yed environment on the PC windows */
/*  */
/* FSM was developed using FSM tool that generates  code of FSM */
/* in this file and in lag_fsm.h   . Code generated beween placeholders */
/*  */
/* Modification history: */
/*  */
/* *************************************************************** */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>

#ifndef WIN32
#include "ttypes.h"
#endif

#include "fsm_example.h"

/* ----------------------------------------------------------------- */
/*    Defines */
/* ----------------------------------------------------------------- */
#define IN_PROGRESS_TIMER_MS 6000

#ifdef FSM_COMPILED
#include \
    "
//  declaration of FSM using pseudo language

// ***********************************
stateMachine
{
lag_fsm ()

// ***********************************

events {
	start_ev           ()
	port_up_ev         (int lacp_enable ,int* port_id)
	port_down_ev       ()
	lacp_up_ev         (int* port_id)
	lacp_down_ev       (int* port_id)
	mismatch_ev        (int* port_id)
	admin_on_ev        ()
	admin_off_ev       ()
}



state idle {
 default	
 transitions {
          { start_ev     , NULL    , admin_down  ,  NULL }
  }

}
// ***********************************
state admin_down {

	transitions {
	  { admin_on_ev     , NULL    , admin_up  ,  on_admin_on() }
 }
ef = admDown
}
// ***********************************
state admin_up {
  tm = 2000
  transitions {
  { port_down_ev      , NULL    , admin_up ,  NULL }
  { port_up_ev        , NULL    , admin_up ,  on_port_up_composed_state() }
  { lacp_down_ev      , NULL    , admin_up ,  on_lacp_down_composed_state() }
  { lacp_up_ev        , NULL    , admin_up ,  on_lacp_up_composed_state() }
  { TIMER_EVENT       , NULL    ,  admin_down   , NULL    }

  { admin_off_ev      , NULL    , admin_down  ,  on_admin_off() }
 }
 substates( lag_down, wait_lag_up, lag_up ,mismatch )
}

// ***********************************
state lag_down {
 transitions {
	{ port_up_ev      , $ ev->lacp_enable $      , wait_lag_up    ,  on_port_up_lacp_enable() }
	{ port_up_ev      , $ else $                 , lag_up         ,  on_port_up_lacp_disable() }
	{ lacp_up_ev      , NULL                     , lag_up         ,  on_lacp_up_in_wait_state()  }
	{ mismatch_ev     , NULL                     , mismatch       ,  on_mismatch() }

 }
 ef = lagDown
 xf = lag
}
// ***********************************
state wait_lag_up {
  tm = IN_PROGRESS_TIMER_MS
  transitions {
   { mismatch_ev          , NULL            , mismatch   , on_mismatch()          }
   { lacp_up_ev           , NULL            , lag_up     , on_lacp_up_in_wait_state() }
   { TIMER_EVENT          , NULL            , lag_down   , on_in_progress_tout()    }
 }
}

// ***********************************

state lag_up {
 transitions {
	{ port_down_ev       , $ fsm->lag == 0 $      , lag_down       ,  on_port_down_last_port()    }
	{ mismatch_ev        , NULL                   , condit1        ,  on_mismatch()   }
	{ lacp_down_ev       , $ fsm->lag  $          , lag_down       ,  on_lacp_down_last_port()        }
 }
}
state condit1 {
  transitions {
       {   NULL_EVENT         , $ fsm->lag == 0 $      , mismatch       ,  on_mismatch()    }
	   {   NULL_EVENT     , $ else $               , lag_up         ,  NULL    }
	}
}

// ***********************************
state mismatch {
 transitions {
    //{ lacp_up_ev       , $ lag->MismatchCleared() $     , lag_up     ,  on_mismatch_cleared(true)  }
    { lacp_down_ev     , $ fsm->lag $     , lag_up     ,  on_mismatch_cleared(1)  }
    { port_down_ev     , $ fsm->lag == NULL $     , lag_up     ,  on_mismatch_cleared(0)  }

 }
}

}// end of stateMachine


"
/* *********************************** */
#endif

/*#$*/
/* The code  inside placeholders  generated by tool and cannot be modifyed*/


/*----------------------------------------------------------------
            Generated enumerator for  Events of FSM
   ---------------------------------------------------------------*/
enum lag_fsm_events_t {
    start_ev = 0,
    port_up_ev = 1,
    port_down_ev = 2,
    lacp_up_ev = 3,
    lacp_down_ev = 4,
    mismatch_ev = 5,
    admin_on_ev = 6,
    admin_off_ev = 7,
};

/*----------------------------------------------------------------
            Generated structures for  Events of FSM
   ---------------------------------------------------------------*/
typedef struct {
    int opcode;
    const char *name;
} lag_fsm_start_ev_t;

typedef struct {
    int opcode;
    const char *name;
    int lacp_enable;
    int*  port_id;
} lag_fsm_port_up_ev_t;

typedef struct {
    int opcode;
    const char *name;
} lag_fsm_port_down_ev_t;

typedef struct {
    int opcode;
    const char *name;
    int*  port_id;
} lag_fsm_lacp_up_ev_t;

typedef struct {
    int opcode;
    const char *name;
    int*  port_id;
} lag_fsm_lacp_down_ev_t;

typedef struct {
    int opcode;
    const char *name;
    int*  port_id;
} lag_fsm_mismatch_ev_t;

typedef struct {
    int opcode;
    const char *name;
} lag_fsm_admin_on_ev_t;

typedef struct {
    int opcode;
    const char *name;
} lag_fsm_admin_off_ev_t;

/*----------------------------------------------------------------
           State entry/exit functions prototypes
   ---------------------------------------------------------------*/
static int admin_down_entry_func(lag_fsm *fsm );
static int lag_down_entry_func(lag_fsm *fsm );
static int lag_down_exit_func(lag_fsm *fsm );
/*----------------------------------------------------------------
            Generated functions for  Events of FSM
   ---------------------------------------------------------------*/
fsm_consume_results
lag_fsm_start_ev(struct lag_fsm  * fsm)
{
    lag_fsm_start_ev_t ev;
    ev.opcode = start_ev;
    ev.name = "start_ev";

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_port_up_ev(struct lag_fsm  * fsm,  int lacp_enable,  int*  port_id)
{
    lag_fsm_port_up_ev_t ev;
    ev.opcode = port_up_ev;
    ev.name = "port_up_ev";
    ev.lacp_enable = lacp_enable;
    ev.port_id = port_id;

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_port_down_ev(struct lag_fsm  * fsm)
{
    lag_fsm_port_down_ev_t ev;
    ev.opcode = port_down_ev;
    ev.name = "port_down_ev";

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_lacp_up_ev(struct lag_fsm  * fsm,  int*  port_id)
{
    lag_fsm_lacp_up_ev_t ev;
    ev.opcode = lacp_up_ev;
    ev.name = "lacp_up_ev";
    ev.port_id = port_id;

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_lacp_down_ev(struct lag_fsm  * fsm,  int*  port_id)
{
    lag_fsm_lacp_down_ev_t ev;
    ev.opcode = lacp_down_ev;
    ev.name = "lacp_down_ev";
    ev.port_id = port_id;

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_mismatch_ev(struct lag_fsm  * fsm,  int*  port_id)
{
    lag_fsm_mismatch_ev_t ev;
    ev.opcode = mismatch_ev;
    ev.name = "mismatch_ev";
    ev.port_id = port_id;

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_admin_on_ev(struct lag_fsm  * fsm)
{
    lag_fsm_admin_on_ev_t ev;
    ev.opcode = admin_on_ev;
    ev.name = "admin_on_ev";

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
fsm_consume_results
lag_fsm_admin_off_ev(struct lag_fsm  * fsm)
{
    lag_fsm_admin_off_ev_t ev;
    ev.opcode = admin_off_ev;
    ev.name = "admin_off_ev";

    return fsm_handle_event(&fsm->base, (fsm_event_base *)&ev);
}
/*----------------------------------------------------------------
                 Reactions of FSM
   ---------------------------------------------------------------*/
static int on_admin_on(lag_fsm  * fsm, int parameter);
static int on_port_up_composed_state(lag_fsm  * fsm, int parameter);
static int on_lacp_down_composed_state(lag_fsm  * fsm, int parameter);
static int on_lacp_up_composed_state(lag_fsm  * fsm, int parameter);
static int on_admin_off(lag_fsm  * fsm, int parameter);
static int on_port_up_lacp_enable(lag_fsm  * fsm, int parameter);
static int on_port_up_lacp_disable(lag_fsm  * fsm, int parameter);
static int on_lacp_up_in_wait_state(lag_fsm  * fsm, int parameter);
static int on_mismatch(lag_fsm  * fsm, int parameter);
static int on_in_progress_tout(lag_fsm  * fsm, int parameter);
static int on_port_down_last_port(lag_fsm  * fsm, int parameter);
static int on_lacp_down_last_port(lag_fsm  * fsm, int parameter);
static int on_mismatch_cleared(lag_fsm  * fsm, int parameter);


/*----------------------------------------------------------------
           State Dispatcher function
   ---------------------------------------------------------------*/
static fsm_state_base* lag_fsm_state_dispatcher( lag_fsm  * fsm,
                                                 uint16 state );
/*----------------------------------------------------------------
           Initialized  State classes of FSM
   ---------------------------------------------------------------*/
fsm_state_base state_lag_fsm_idle;
fsm_state_base state_lag_fsm_admin_down;
fsm_state_base state_lag_fsm_admin_up;
fsm_state_base state_lag_fsm_lag_down;
fsm_state_base state_lag_fsm_wait_lag_up;
fsm_state_base state_lag_fsm_lag_up;
fsm_state_base state_lag_fsm_condit1;
fsm_state_base state_lag_fsm_mismatch;


fsm_state_base state_lag_fsm_idle =
{ "idle", lag_fsm_idle, SIMPLE, NULL, NULL, &lag_fsm_state_dispatcher, NULL,
  NULL };

fsm_state_base state_lag_fsm_admin_down =
{ "admin_down", lag_fsm_admin_down, SIMPLE, NULL, NULL,
  &lag_fsm_state_dispatcher, admin_down_entry_func, NULL };

fsm_state_base state_lag_fsm_admin_up =
{ "admin_up", lag_fsm_admin_up,  COMPOSED, NULL, &state_lag_fsm_lag_down,
  &lag_fsm_state_dispatcher, NULL, NULL };

fsm_state_base state_lag_fsm_lag_down =
{ "lag_down", lag_fsm_lag_down, SIMPLE, &state_lag_fsm_admin_up, NULL,
  &lag_fsm_state_dispatcher, lag_down_entry_func, lag_down_exit_func };

fsm_state_base state_lag_fsm_wait_lag_up =
{ "wait_lag_up", lag_fsm_wait_lag_up, SIMPLE, &state_lag_fsm_admin_up, NULL,
  &lag_fsm_state_dispatcher, NULL, NULL };

fsm_state_base state_lag_fsm_lag_up =
{ "lag_up", lag_fsm_lag_up, SIMPLE, &state_lag_fsm_admin_up, NULL,
  &lag_fsm_state_dispatcher, NULL, NULL };

fsm_state_base state_lag_fsm_condit1 =
{ "condit1", lag_fsm_condit1,  CONDITION, NULL, NULL,
  &lag_fsm_state_dispatcher, NULL, NULL};

fsm_state_base state_lag_fsm_mismatch =
{ "mismatch", lag_fsm_mismatch, SIMPLE, &state_lag_fsm_admin_up, NULL,
  &lag_fsm_state_dispatcher, NULL, NULL };

static fsm_state_base * default_state = &state_lag_fsm_idle;
/*----------------------------------------------------------------
           StateDispatcher of FSM
   ---------------------------------------------------------------*/

static fsm_state_base*
lag_fsm_state_dispatcher( lag_fsm  * fsm, uint16 state )
{
    fsm_timer_event *event = (  fsm_timer_event * )fsm->base.current_event;
    switch (state) {

    case lag_fsm_idle:
        if (event->opcode == start_ev) {
            SET_EVENT(lag_fsm, start_ev)
            { /*tr00:*/
                /* Source line = 59*/
                return &state_lag_fsm_admin_down;
            }
        }

        break;

    case lag_fsm_admin_down:
        if (event->opcode == admin_on_ev) {
            SET_EVENT(lag_fsm, admin_on_ev)
            { /*tr10:*/
                fsm->base.err = on_admin_on( fsm, DEFAULT_PARAMS_D); /* Source line = 67*/
                return &state_lag_fsm_admin_up;
            }
        }

        break;

    case lag_fsm_admin_up:
        if (event->opcode == port_down_ev) {
            SET_EVENT(lag_fsm, port_down_ev)
            { /*tr20:*/
                /* Source line = 75*/
                return &state_lag_fsm_admin_up;
            }
        }else if (event->opcode == port_up_ev) {
            SET_EVENT(lag_fsm, port_up_ev)
            { /*tr21:*/
                fsm->base.err = on_port_up_composed_state( fsm,
                                                           DEFAULT_PARAMS_D);   /* Source line = 76*/
                return &state_lag_fsm_admin_up;
            }
        }else if (event->opcode == lacp_down_ev) {
            SET_EVENT(lag_fsm, lacp_down_ev)
            { /*tr22:*/
                fsm->base.err = on_lacp_down_composed_state( fsm,
                                                             DEFAULT_PARAMS_D);   /* Source line = 77*/
                return &state_lag_fsm_admin_up;
            }
        }else if (event->opcode == lacp_up_ev) {
            SET_EVENT(lag_fsm, lacp_up_ev)
            { /*tr23:*/
                fsm->base.err = on_lacp_up_composed_state( fsm,
                                                           DEFAULT_PARAMS_D);   /* Source line = 78*/
                return &state_lag_fsm_admin_up;
            }
        }else if ((event->opcode == TIMER_EVENT) &&
                  (event->id == lag_fsm_admin_up)) {
            { /*tr24:*/
                /* Source line = 79*/
                return &state_lag_fsm_admin_down;
            }
        }else if (event->opcode == admin_off_ev) {
            SET_EVENT(lag_fsm, admin_off_ev)
            { /*tr25:*/
                fsm->base.err = on_admin_off( fsm, DEFAULT_PARAMS_D); /* Source line = 81*/
                return &state_lag_fsm_admin_down;
            }
        }

        break;

    case lag_fsm_lag_down:
        if (event->opcode == port_up_ev) {
            SET_EVENT(lag_fsm, port_up_ev)
            if (ev->lacp_enable) { /*tr30:*/
                fsm->base.err = on_port_up_lacp_enable( fsm, DEFAULT_PARAMS_D); /* Source line = 89*/
                return &state_lag_fsm_wait_lag_up;
            }else { /*tr31:*/
                fsm->base.err =
                    on_port_up_lacp_disable( fsm, DEFAULT_PARAMS_D);          /* Source line = 90*/
                return &state_lag_fsm_lag_up;
            }
        }else if (event->opcode == lacp_up_ev) {
            SET_EVENT(lag_fsm, lacp_up_ev)
            { /*tr32:*/
                fsm->base.err =
                    on_lacp_up_in_wait_state( fsm, DEFAULT_PARAMS_D);          /* Source line = 91*/
                return &state_lag_fsm_lag_up;
            }
        }else if (event->opcode == mismatch_ev) {
            SET_EVENT(lag_fsm, mismatch_ev)
            { /*tr33:*/
                fsm->base.err = on_mismatch( fsm, DEFAULT_PARAMS_D); /* Source line = 92*/
                return &state_lag_fsm_mismatch;
            }
        }

        break;

    case lag_fsm_wait_lag_up:
        if (event->opcode == mismatch_ev) {
            SET_EVENT(lag_fsm, mismatch_ev)
            { /*tr40:*/
                fsm->base.err = on_mismatch( fsm, DEFAULT_PARAMS_D); /* Source line = 102*/
                return &state_lag_fsm_mismatch;
            }
        }else if (event->opcode == lacp_up_ev) {
            SET_EVENT(lag_fsm, lacp_up_ev)
            { /*tr41:*/
                fsm->base.err =
                    on_lacp_up_in_wait_state( fsm, DEFAULT_PARAMS_D);          /* Source line = 103*/
                return &state_lag_fsm_lag_up;
            }
        }else if ((event->opcode == TIMER_EVENT) &&
                  (event->id == lag_fsm_wait_lag_up)) {
            { /*tr42:*/
                fsm->base.err = on_in_progress_tout( fsm, DEFAULT_PARAMS_D); /* Source line = 104*/
                return &state_lag_fsm_lag_down;
            }
        }

        break;

    case lag_fsm_lag_up:
        if (event->opcode == port_down_ev) {
            SET_EVENT(lag_fsm, port_down_ev)
            if (fsm->lag == 0) { /*tr50:*/
                fsm->base.err = on_port_down_last_port( fsm, DEFAULT_PARAMS_D); /* Source line = 112*/
                return &state_lag_fsm_lag_down;
            }
        }else if (event->opcode == mismatch_ev) {
            SET_EVENT(lag_fsm, mismatch_ev)
            { /*tr51:*/
                fsm->base.err = on_mismatch( fsm, DEFAULT_PARAMS_D); /* Source line = 113*/
                return &state_lag_fsm_condit1;
            }
        }else if (event->opcode == lacp_down_ev) {
            SET_EVENT(lag_fsm, lacp_down_ev)
            if (fsm->lag) { /*tr52:*/
                fsm->base.err = on_lacp_down_last_port( fsm, DEFAULT_PARAMS_D); /* Source line = 114*/
                return &state_lag_fsm_lag_down;
            }
        }

        break;

    case lag_fsm_condit1:
        {
            if (fsm->lag == 0) { /*tr60:*/
                fsm->base.err = on_mismatch( fsm, DEFAULT_PARAMS_D); /* Source line = 119*/
                return &state_lag_fsm_mismatch;
            }else { /*tr61:*/
                /* Source line = 120*/
                return &state_lag_fsm_lag_up;
            }
        }

        break;

    case lag_fsm_mismatch:
        if (event->opcode == lacp_down_ev) {
            SET_EVENT(lag_fsm, lacp_down_ev)
            if (fsm->lag) { /*tr70:*/
                fsm->base.err = on_mismatch_cleared( fsm, 1); /* Source line = 128*/
                return &state_lag_fsm_lag_up;
            }
        }else if (event->opcode == port_down_ev) {
            SET_EVENT(lag_fsm, port_down_ev)
            { /*tr71:*/
                fsm->base.err = on_mismatch_cleared( fsm, 0); /* Source line = 129*/
                return &state_lag_fsm_lag_up;
            }
        }

        break;

    default:
        break;

    }
    return NULL;

}
/*----------------------------------------------------------------
              Constructor of FSM
   ---------------------------------------------------------------*/
int
lag_fsm_init(struct lag_fsm *fsm, fsm_user_trace user_trace, void * sched_func,
             void * unsched_func)
{
    fsm->state_timer[lag_fsm_idle] = 0;
    fsm->state_timer[lag_fsm_admin_down] = 0;
    fsm->state_timer[lag_fsm_admin_up] = 2000;
    fsm->state_timer[lag_fsm_lag_down] = 0;
    fsm->state_timer[lag_fsm_wait_lag_up] = IN_PROGRESS_TIMER_MS;
    fsm->state_timer[lag_fsm_lag_up] = 0;
    fsm->state_timer[lag_fsm_condit1] = 0;
    fsm->state_timer[lag_fsm_mismatch] = 0;
    fsm_init(&fsm->base,  default_state, 8, fsm->state_timer, user_trace,
             sched_func, unsched_func);

    return 0;
}
/*  per state functions*/
/*----------------------------------------------------------------
              Getters for each State
   ---------------------------------------------------------------*/
tbool
lag_fsm_idle_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_idle);
}
tbool
lag_fsm_admin_down_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_admin_down);
}
tbool
lag_fsm_admin_up_in(struct lag_fsm *fsm){
    return fsm->base.curr_state->composed &&
           (fsm->base.curr_state->composed->id == lag_fsm_admin_up);
}
tbool
lag_fsm_lag_down_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_lag_down);
}
tbool
lag_fsm_wait_lag_up_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_wait_lag_up);
}
tbool
lag_fsm_lag_up_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_lag_up);
}
tbool
lag_fsm_condit1_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_condit1);
}
tbool
lag_fsm_mismatch_in(struct lag_fsm *fsm){
    return (fsm->base.curr_state->id == lag_fsm_mismatch);
}
/*----------------------------------------------------------------
                 Reactions of FSM  (within comments . user may paste function body outside placeholder region)
   ---------------------------------------------------------------*/

/*static  int on_admin_on (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , admin_on_ev) ;
   }
   static  int on_port_up_composed_state (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , port_up_ev) ;
   }
   static  int on_lacp_down_composed_state (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , lacp_down_ev) ;
   }
   static  int on_lacp_up_composed_state (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , lacp_up_ev) ;
   }
   static  int on_admin_off (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , admin_off_ev) ;
   }
   static  int on_port_up_lacp_enable (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , port_up_ev) ;
   }
   static  int on_port_up_lacp_disable (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , port_up_ev) ;
   }
   static  int on_lacp_up_in_wait_state (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , lacp_up_ev) ;
   }
   static  int on_mismatch (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , mismatch_ev) ;
   }
   static  int on_in_progress_tout (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , TIMER_EVENT) ;
   }
   static  int on_port_down_last_port (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , port_down_ev) ;
   }
   static  int on_lacp_down_last_port (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , lacp_down_ev) ;
   }
   static  int on_mismatch_cleared (lag_fsm  * fsm, int parameter)
   {
   SET_EVENT(lag_fsm , lacp_down_ev) ;
   }


 */
/*   17319*/

/*#$*/

/* Below code written by user */


/* ---------------------------------------------------------------------- */
/*                       lag_fsm::Print() */
/* Purpose:           Implementation for virtual trace  function */
/*  */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
void
UserTrace( void* theBuf, int theLen )
{
/*   if (LAG_FSM_TRACE.IsToTrace())   Logger::Print("lag_fsm  :%s", theBuf); */
}



/* ---------------------------------------------------------------------- */
/*                        on_admin_on */
/* Purpose:         called when FSM passes to adminUp state */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_admin_on(lag_fsm  * theFsmP, int parameter )
{
    /* SET_EVENT(lag_fsm , AdminOnEv) ; */
    /* lag->HandleAdminStatusChange(); */
    /* CalculateAlarm(LAG_ADMIN_UP); */
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                       on_admin_off */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_admin_off( lag_fsm  * theFsmP, int parameter )
{
    /* lag->HandleAdminStatusChange(); */
    /* CalculateAlarm(LAG_ADMIN_DOWN); */
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                       on_port_up_composed_state */
/* Purpose:          called in Composed state */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */

int
on_port_up_composed_state( lag_fsm *fsm, int parameter )
{
    SET_EVENT(lag_fsm, port_up_ev);
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                        on_port_up_lacp_enable */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_port_up_lacp_enable( lag_fsm  * fsm, int parameter )
{
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                        on_port_up_lacp_disable */
/* Purpose:          called when passes to Lag Up state */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_port_up_lacp_disable( lag_fsm  * fsm, int parameter )
{
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                      on_port_down_last_port */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */

int
on_port_down_last_port( lag_fsm  * theFsmP, int parameter )
{
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                       on_in_progress_tout */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */

int
on_in_progress_tout(lag_fsm  * theFsmP,  int parameter )
{
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                        on_mismatch */
/* Purpose:          called when passes to Mismatch state */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_mismatch(lag_fsm  * fsm,  int parameter )
{
    SET_EVENT(lag_fsm, mismatch_ev);
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                        on_lacp_up_in_wait_state */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_lacp_up_in_wait_state(lag_fsm  * fsm, int parameter )
{
    SET_EVENT(lag_fsm, lacp_up_ev);
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                        on_lacp_down_last_port */
/* Purpose:          called in Lag Up state .  pases to Lag down */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_lacp_down_last_port(lag_fsm  * fsm, int parameter )
{
    SET_EVENT(lag_fsm, lacp_down_ev);
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                        on_lacp_down_composed_state */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_lacp_down_composed_state(lag_fsm  * theFsmP, int parameter )
{
    return 0;
}


/* ---------------------------------------------------------------------- */
/*                       on_lacp_up_composed_state */
/* Purpose:          called in Composed state */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
int
on_lacp_up_composed_state(lag_fsm  * theFsmP, int parameter )
{
    return 0;
}


static int
admin_down_entry_func(lag_fsm *pFsm )
{
    printf("called %s\n", __FUNCTION__);
    return 0;
}
static int
lag_down_entry_func(lag_fsm *pFsm )
{
    printf("called %s\n", __FUNCTION__);
    return 0;
}
static int
lag_down_exit_func(lag_fsm *pFsm )
{
    printf("called %s\n", __FUNCTION__);
    return 0;
}

/* ---------------------------------------------------------------------- */
/*                        :on_mismatch_cleared */
/* Purpose:          called when passes to adminDownState */
/* Input  :      none */
/* Output :      none */
/* Precondition: */
/*  */
/* Returns:  none */
/* ----------------------------------------------------------------------- */
static int
on_mismatch_cleared(lag_fsm  * fsm, int parameter)
{
    SET_EVENT(lag_fsm, lacp_down_ev);
    return 0;
}

